"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/already";
exports.ids = ["vendor-chunks/already"];
exports.modules = {

/***/ "(rsc)/./node_modules/already/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/already/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deferSet = exports.OrderedAsynchrony = exports.funnel = exports.wrapFunction = exports.rethrow = exports.specific = exports.deferInspectable = exports.inspect = exports.reflect = exports.defer = exports.retry = exports.once = exports.some = exports.eachImpl = exports.each = exports.reduce = exports.map = exports.filter = exports.props = exports.tap = exports.delayChain = exports.delay = exports.concurrent = void 0;\nexports[\"default\"] = {\n    defer,\n    deferSet,\n    delay,\n    delayChain,\n    each,\n    filter,\n    funnel,\n    inspect,\n    map,\n    once,\n    props,\n    reduce,\n    rethrow,\n    retry,\n    some,\n    specific,\n    tap,\n    wrapFunction,\n};\nfunction toReadonlyArray(arr) {\n    /* istanbul ignore else */\n    if (typeof arr.map === \"function\")\n        return arr;\n    else\n        return Array.from(arr);\n}\nfunction concurrent(size, fn) {\n    const queue = makeQueue(size);\n    if (size < 1)\n        throw new RangeError(`Size must be at least 1`);\n    if (!fn)\n        return (cb, ...args) => queue.enqueue(() => cb(...args));\n    else\n        return (...args) => queue.enqueue(() => fn(...args));\n}\nexports.concurrent = concurrent;\nfunction makeQueue(size) {\n    const queue = {\n        size,\n        count: 0,\n        queue: [],\n        process: () => {\n            if (queue.queue.length) {\n                const first = queue.queue.shift();\n                const { cb, deferred } = first;\n                queue.runOne(cb).then(deferred.resolve, deferred.reject);\n            }\n        },\n        runOne: (cb) => {\n            ++queue.count;\n            return (async () => cb())()\n                .finally(() => {\n                --queue.count;\n                queue.process();\n            });\n        },\n        enqueue: async (cb) => {\n            if (queue.count >= queue.size) {\n                const deferred = defer();\n                queue.queue.push({ cb, deferred });\n                return deferred.promise;\n            }\n            return queue.runOne(cb);\n        }\n    };\n    return queue;\n}\nfunction delay(milliseconds, t) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(t), milliseconds);\n    });\n}\nexports.delay = delay;\nfunction delayChain(milliseconds) {\n    return tap(() => delay(milliseconds));\n}\nexports.delayChain = delayChain;\nfunction tap(fn) {\n    return async (t) => {\n        await fn(t);\n        return t;\n    };\n}\nexports.tap = tap;\nfunction props(obj) {\n    const ret = {};\n    const awaiters = [];\n    for (const prop of Object.keys(obj))\n        awaiters.push(Promise.resolve(obj[prop])\n            .then(val => { ret[prop] = val; }));\n    return Promise.all(awaiters).then(() => ret);\n}\nexports.props = props;\nconst defaultFilterMapOptions = { concurrency: Infinity };\nfunction filter(arr, opts, filterFn) {\n    if (Array.isArray(arr)) {\n        if (typeof opts === \"function\") {\n            filterFn = opts;\n            opts = defaultFilterMapOptions;\n        }\n        const intermediate = filter(opts, filterFn);\n        return intermediate(arr);\n    }\n    filterFn = typeof arr === \"function\" ? arr : opts;\n    opts =\n        typeof arr === \"function\"\n            ? defaultFilterMapOptions\n            : arr;\n    const wrappedFilterFn = (val, index, arr) => Promise.resolve(filterFn(val, index, arr))\n        .then(ok => ({ ok, val }));\n    return (t) => {\n        return map(opts, wrappedFilterFn)(t)\n            .then(values => values\n            .filter(({ ok }) => ok)\n            .map(({ val }) => val));\n    };\n}\nexports.filter = filter;\nfunction map(arr, opts, mapFn) {\n    if (Array.isArray(arr)) {\n        if (typeof opts === \"function\") {\n            mapFn = opts;\n            opts = defaultFilterMapOptions;\n        }\n        return map(opts, mapFn)(arr);\n    }\n    mapFn = typeof arr === \"function\" ? arr : opts;\n    opts =\n        typeof arr === \"function\"\n            ? defaultFilterMapOptions\n            : arr;\n    const { concurrency = Infinity } = opts;\n    const promiseMapFn = (t, index, arr) => Promise.resolve(mapFn(t, index, arr));\n    const concurrently = concurrent(concurrency);\n    return (t) => {\n        return Promise.resolve(t)\n            .then((values) => toReadonlyArray(values).map((val, index, arr) => (() => Promise.resolve(val))()\n            .then((val) => concurrently(promiseMapFn, val, index, arr))))\n            .then(values => Promise.all(values));\n    };\n}\nexports.map = map;\nfunction reduce(input, reducer, initialValue) {\n    if (typeof input === \"function\") {\n        initialValue = reducer;\n        const _reducer = input;\n        return async (input) => {\n            return reduceImpl(input, _reducer, initialValue);\n        };\n    }\n    return reduceImpl(input, reducer, initialValue);\n}\nexports.reduce = reduce;\nasync function reduceImpl(input, reducer, initialValue) {\n    const _input = Array.from(await input);\n    const _initialValue = await initialValue;\n    if (_input.length === 0)\n        return _initialValue;\n    const usingInitialValue = typeof _initialValue !== \"undefined\";\n    const length = _input.length;\n    let index = usingInitialValue ? 0 : 1;\n    let accumulator = usingInitialValue\n        ? _initialValue\n        // This cast should be safe if the interface is respected\n        : await _input.shift();\n    while (_input.length > 0)\n        accumulator = await reducer(accumulator, await _input.shift(), index++, length);\n    return accumulator;\n}\nfunction each(arr, eachFn) {\n    if (Array.isArray(arr))\n        return eachImpl(eachFn)(arr);\n    return eachImpl(arr);\n}\nexports.each = each;\nfunction eachImpl(eachFn) {\n    return async (arr) => {\n        const length = arr.length;\n        async function iterator(t, index) {\n            await eachFn(t, index, length);\n            return t;\n        }\n        return map(arr, { concurrency: 1 }, iterator);\n    };\n}\nexports.eachImpl = eachImpl;\nfunction some(list, fn) {\n    if (typeof list === \"function\") {\n        fn = list;\n        return (list) => someImpl(list, fn);\n    }\n    return someImpl(list, fn);\n}\nexports.some = some;\nasync function someImpl(list, fn) {\n    const _list = toReadonlyArray(await list);\n    for (const val of _list) {\n        const ret = await fn(await val);\n        if (ret)\n            return ret;\n    }\n    return false;\n}\nfunction once(fn) {\n    if (fn) {\n        const _once = onceDynamic();\n        return ((t) => _once(fn, t));\n    }\n    else\n        return onceDynamic();\n}\nexports.once = once;\nfunction onceDynamic() {\n    const state = new WeakMap();\n    const ensureState = (fn) => {\n        if (!state.has(fn))\n            state.set(fn, { hasRun: false });\n    };\n    return ((fn, t) => {\n        ensureState(fn);\n        const stateObject = state.get(fn);\n        if (stateObject.hasRun) {\n            if (stateObject.deferred)\n                return stateObject.deferred.promise;\n            return stateObject.returnValue;\n        }\n        stateObject.hasRun = true;\n        const ret = fn(t);\n        const pret = ret;\n        if (pret !== undefined && pret && typeof pret.then === \"function\") {\n            stateObject.deferred = defer(void 0);\n            return pret\n                .then(stateObject.deferred.resolve, rethrow(stateObject.deferred.reject))\n                .then(() => stateObject.deferred.promise);\n        }\n        stateObject.returnValue = ret;\n        return ret;\n    });\n}\nfunction retry(times, fn, retryable = () => true) {\n    const retryAsync = (promise) => promise\n        .catch((err) => {\n        if (--times < 0 || !retryable(err))\n            throw err;\n        return retryAsync(fn());\n    });\n    const retrySync = (_err) => {\n        while (--times >= 0) {\n            try {\n                return fn();\n            }\n            catch (err) {\n                if (!retryable(err))\n                    throw err;\n                _err = err;\n            }\n        }\n        throw _err;\n    };\n    try {\n        const ret = fn();\n        if (ret &&\n            typeof ret === \"object\" &&\n            typeof ret.then === \"function\") {\n            return retryAsync(ret);\n        }\n        return ret;\n    }\n    catch (err) {\n        if (!retryable(err))\n            throw err;\n        return retrySync(err);\n    }\n}\nexports.retry = retry;\nfunction defer() {\n    var _a;\n    const deferred = {};\n    deferred.promise = new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    });\n    /* istanbul ignore next */\n    if (((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== undefined)\n        try {\n            // Jest has decided for many versions to break async catching,\n            // so this is needed for unit tests not to break unnecessarily.\n            deferred.promise.catch(() => { });\n        }\n        catch (_err) { }\n    return deferred;\n}\nexports.defer = defer;\nfunction reflect(promise) {\n    const inspection = inspect(promise);\n    function handleResolution(value) {\n        return {\n            isRejected: false,\n            isResolved: true,\n            value,\n        };\n    }\n    function handleRejection(error) {\n        return {\n            error,\n            isRejected: true,\n            isResolved: false,\n        };\n    }\n    return inspection.promise\n        .then(handleResolution, handleRejection);\n}\nexports.reflect = reflect;\nfunction inspect(promise) {\n    const inspectable = {\n        isPending: true,\n        isRejected: false,\n        isResolved: false,\n        promise: void 0,\n    };\n    inspectable.promise = promise.then(value => {\n        inspectable.isResolved = true;\n        inspectable.isPending = false;\n        return value;\n    })\n        .catch(err => {\n        inspectable.isRejected = true;\n        inspectable.isPending = false;\n        return Promise.reject(err);\n    });\n    return inspectable;\n}\nexports.inspect = inspect;\nfunction deferInspectable() {\n    const deferred = defer();\n    const ret = {\n        isPending: true,\n        isRejected: false,\n        isResolved: false,\n        promise: deferred.promise,\n        resolve(t) {\n            if (!ret.isPending)\n                return;\n            deferred.resolve(t);\n            ret.isPending = false;\n            ret.isRejected = false;\n            ret.isResolved = true;\n        },\n        reject(err) {\n            if (!ret.isPending)\n                return;\n            deferred.reject(err);\n            ret.isPending = false;\n            ret.isRejected = true;\n            ret.isResolved = false;\n        },\n    };\n    return ret;\n}\nexports.deferInspectable = deferInspectable;\n// This logic is taken from Bluebird\nfunction catchFilter(filters, err) {\n    return (Array.isArray(filters) ? filters : [filters])\n        .some((filter) => {\n        if (filter == null)\n            return false;\n        if (filter === Error ||\n            filter.prototype instanceof Error) {\n            if (err instanceof filter)\n                return true;\n        }\n        else if (typeof filter === \"function\") {\n            const filterFn = filter;\n            // It is \"ok\" for this to throw. It'll be thrown back to the catch\n            // handler, and the promise chain will contain this error.\n            return filterFn(err);\n        }\n        else if (typeof filter === \"object\") {\n            const obj = filter;\n            for (const key of Object.keys(obj))\n                if (obj[key] !== err[key])\n                    return false;\n            return true;\n        }\n        return false;\n    });\n}\nfunction specific(filters, handler) {\n    return (err) => {\n        if (!catchFilter(filters, err))\n            throw err;\n        return handler(err);\n    };\n}\nexports.specific = specific;\nfunction rethrow(fn) {\n    return async (err) => {\n        await fn(err);\n        throw err;\n    };\n}\nexports.rethrow = rethrow;\nfunction wrapFunction(wrap) {\n    // tslint:disable-next-line\n    return function (t, cb) {\n        if (arguments.length === 1) {\n            if (wrap.length > 0)\n                throw new EvalError(\"Invalid invocation, function requires 2 arguments\");\n            cb = t;\n            t = void 0;\n        }\n        const anyCleanup = wrap(t);\n        const callCleanup = (cleanup) => {\n            if (typeof cleanup === \"function\")\n                return cleanup();\n            else if (cleanup != null)\n                // Allow 'before' to just return null/undefined, but non-empty\n                // value would've been silently ignored.\n                throw new EvalError(\"Invalid return value in 'before' handler\");\n        };\n        if (anyCleanup &&\n            typeof anyCleanup.then === \"function\") {\n            let doCleanup;\n            return anyCleanup\n                .then(async (cleanup) => {\n                doCleanup = () => callCleanup(cleanup);\n                return cb();\n            })\n                .finally(() => {\n                if (doCleanup)\n                    return doCleanup();\n            });\n        }\n        else {\n            const cleanup = anyCleanup;\n            let cbRet;\n            try {\n                cbRet = cb();\n            }\n            catch (err) {\n                const cleanupRet = callCleanup(cleanup);\n                if (cleanupRet &&\n                    typeof cleanupRet.then === \"function\") {\n                    return cleanupRet\n                        .then(() => { throw err; });\n                }\n                else {\n                    throw err;\n                }\n            }\n            if (cbRet && typeof cbRet.then === \"function\") {\n                return cbRet\n                    .finally(() => callCleanup(cleanup));\n            }\n            else {\n                const cleanupRet = callCleanup(cleanup);\n                if (cleanupRet &&\n                    typeof cleanupRet.then === \"function\") {\n                    return cleanupRet\n                        .then(() => cbRet);\n                }\n                else {\n                    return cbRet;\n                }\n            }\n        }\n    };\n}\nexports.wrapFunction = wrapFunction;\nfunction funnel(opts = {}) {\n    const { onEmpty, concurrency = 1 } = (opts || {});\n    let FunnelState;\n    (function (FunnelState) {\n        FunnelState[FunnelState[\"DEFAULT\"] = 0] = \"DEFAULT\";\n        FunnelState[FunnelState[\"SHOULD_RETRY\"] = 1] = \"SHOULD_RETRY\";\n        FunnelState[FunnelState[\"WAITING\"] = 2] = \"WAITING\";\n        FunnelState[FunnelState[\"COMPLETED\"] = 3] = \"COMPLETED\";\n    })(FunnelState || (FunnelState = {}));\n    /**\n     * All ongoing tasks (functions) regardless of state they are in.\n     * If they return/throw or shortcut, they get cleared from this map.\n     * The order is preserved for fifo fairness.\n     */\n    const tasks = new Map();\n    const countWaiting = () => {\n        return [...tasks.values()]\n            .filter(({ state }) => state === FunnelState.WAITING)\n            .length;\n    };\n    const countWorking = () => {\n        return [...tasks.values()]\n            .filter(({ state }) => state === FunnelState.SHOULD_RETRY)\n            .length;\n    };\n    const freeSlots = () => {\n        return Math.max(0, concurrency - countWorking());\n    };\n    const triggerWaiting = () => {\n        const amountToResume = freeSlots();\n        [...tasks.values()]\n            .filter(({ state }) => state === FunnelState.WAITING)\n            .slice(0, amountToResume)\n            .forEach(task => {\n            task.resume();\n        });\n    };\n    return (fn) => {\n        const sentry = {};\n        const store = {\n            state: FunnelState.DEFAULT,\n            counted: false,\n            resume: undefined,\n        };\n        tasks.set(sentry, store);\n        const shouldRetry = () => {\n            if (store.state === FunnelState.COMPLETED)\n                // shortcut before should/retry shortcuts through\n                return false;\n            const free = freeSlots();\n            const shouldContinue = free > 0;\n            if (store.state !== FunnelState.DEFAULT)\n                throw new Error(\"Invalid use of 'shouldRetry'\");\n            store.state = FunnelState.SHOULD_RETRY;\n            store.counted = true;\n            return !shouldContinue;\n        };\n        const retry = () => {\n            if (store.state !== FunnelState.SHOULD_RETRY)\n                throw new Error(\"Invalid use of 'retry', \" +\n                    \"must only be called after 'shouldRetry'\");\n            store.state = FunnelState.WAITING;\n            const deferred = defer();\n            const resume = () => {\n                store.state = FunnelState.DEFAULT;\n                store.resume = undefined;\n                deferred.resolve(runner());\n            };\n            store.resume = resume;\n            return deferred.promise;\n        };\n        const shortcut = () => {\n            if (store.state === FunnelState.COMPLETED)\n                return;\n            store.state = FunnelState.COMPLETED;\n            tasks.delete(sentry);\n            if (countWaiting() === 0)\n                onEmpty === null || onEmpty === void 0 ? void 0 : onEmpty();\n            else\n                triggerWaiting();\n        };\n        const runner = () => {\n            return (async () => fn(shouldRetry, retry, shortcut))()\n                .finally(shortcut);\n        };\n        return runner();\n    };\n}\nexports.funnel = funnel;\nclass OrderedAsynchrony {\n    constructor() {\n        this.deferrals = [];\n    }\n    wait(waitForIndex, resolveIndex, rejectIndex) {\n        this.ensureDeferral([\n            ...([].concat(waitForIndex)),\n            ...(resolveIndex == null ? [] :\n                [].concat(resolveIndex)),\n            ...(rejectIndex == null ? [] :\n                [].concat(rejectIndex)),\n        ]);\n        return this.decorate(Promise.all([].concat(waitForIndex)\n            .map(index => this.deferrals[index].promise))\n            .then(() => Promise.all([\n            resolveIndex == null\n                ? void 0\n                : this.resolve(resolveIndex),\n            rejectIndex == null\n                ? void 0\n                : this.reject(rejectIndex),\n        ])\n            .then(() => { })));\n    }\n    resolve(index) {\n        this.ensureDeferral(index);\n        return this.decorate(delay(0).then(() => {\n            [].concat(index)\n                .forEach(index => {\n                this.deferrals[index].resolve();\n            });\n        }));\n    }\n    reject(index, error = new Error(\"OrderedAsynchrony rejection\")) {\n        this.ensureDeferral(index);\n        return this.decorate(delay(0).then(() => {\n            [].concat(index)\n                .forEach(index => {\n                this.deferrals[index].reject(error);\n            });\n        }));\n    }\n    ensureDeferral(index) {\n        const indices = []\n            .concat(index)\n            .sort((a, b) => b - a);\n        const highest = indices[0];\n        for (let i = this.deferrals.length; i <= highest; ++i)\n            this.deferrals.push(defer(void 0));\n        return this;\n    }\n    decorate(promise) {\n        // tslint:disable-next-line:variable-name\n        const This = {\n            decorate: this.decorate.bind(this),\n            deferrals: this.deferrals,\n            ensureDeferral: this.ensureDeferral.bind(this),\n            reject: this.reject.bind(this),\n            resolve: this.resolve.bind(this),\n            wait: this.wait.bind(this),\n        };\n        return Object.assign(promise, This);\n    }\n}\nexports.OrderedAsynchrony = OrderedAsynchrony;\nfunction deferSet() {\n    return new OrderedAsynchrony();\n}\nexports.deferSet = deferSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWxyZWFkeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHlCQUF5QixHQUFHLGNBQWMsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsa0JBQWtCLEdBQUcsYUFBYSxHQUFHLGtCQUFrQjtBQUNoYSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsWUFBWSwyQkFBMkIsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtDQUFrQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvbGFldGl0aWF2YW5kZXJ2ZWtlbi9EZXNrdG9wL3NlZW4tYXBwcy9ub2RlX21vZHVsZXMvYWxyZWFkeS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZlclNldCA9IGV4cG9ydHMuT3JkZXJlZEFzeW5jaHJvbnkgPSBleHBvcnRzLmZ1bm5lbCA9IGV4cG9ydHMud3JhcEZ1bmN0aW9uID0gZXhwb3J0cy5yZXRocm93ID0gZXhwb3J0cy5zcGVjaWZpYyA9IGV4cG9ydHMuZGVmZXJJbnNwZWN0YWJsZSA9IGV4cG9ydHMuaW5zcGVjdCA9IGV4cG9ydHMucmVmbGVjdCA9IGV4cG9ydHMuZGVmZXIgPSBleHBvcnRzLnJldHJ5ID0gZXhwb3J0cy5vbmNlID0gZXhwb3J0cy5zb21lID0gZXhwb3J0cy5lYWNoSW1wbCA9IGV4cG9ydHMuZWFjaCA9IGV4cG9ydHMucmVkdWNlID0gZXhwb3J0cy5tYXAgPSBleHBvcnRzLmZpbHRlciA9IGV4cG9ydHMucHJvcHMgPSBleHBvcnRzLnRhcCA9IGV4cG9ydHMuZGVsYXlDaGFpbiA9IGV4cG9ydHMuZGVsYXkgPSBleHBvcnRzLmNvbmN1cnJlbnQgPSB2b2lkIDA7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgZGVmZXIsXG4gICAgZGVmZXJTZXQsXG4gICAgZGVsYXksXG4gICAgZGVsYXlDaGFpbixcbiAgICBlYWNoLFxuICAgIGZpbHRlcixcbiAgICBmdW5uZWwsXG4gICAgaW5zcGVjdCxcbiAgICBtYXAsXG4gICAgb25jZSxcbiAgICBwcm9wcyxcbiAgICByZWR1Y2UsXG4gICAgcmV0aHJvdyxcbiAgICByZXRyeSxcbiAgICBzb21lLFxuICAgIHNwZWNpZmljLFxuICAgIHRhcCxcbiAgICB3cmFwRnVuY3Rpb24sXG59O1xuZnVuY3Rpb24gdG9SZWFkb25seUFycmF5KGFycikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBhcnIubWFwID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xufVxuZnVuY3Rpb24gY29uY3VycmVudChzaXplLCBmbikge1xuICAgIGNvbnN0IHF1ZXVlID0gbWFrZVF1ZXVlKHNpemUpO1xuICAgIGlmIChzaXplIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNpemUgbXVzdCBiZSBhdCBsZWFzdCAxYCk7XG4gICAgaWYgKCFmbilcbiAgICAgICAgcmV0dXJuIChjYiwgLi4uYXJncykgPT4gcXVldWUuZW5xdWV1ZSgoKSA9PiBjYiguLi5hcmdzKSk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHF1ZXVlLmVucXVldWUoKCkgPT4gZm4oLi4uYXJncykpO1xufVxuZXhwb3J0cy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbmZ1bmN0aW9uIG1ha2VRdWV1ZShzaXplKSB7XG4gICAgY29uc3QgcXVldWUgPSB7XG4gICAgICAgIHNpemUsXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBxdWV1ZTogW10sXG4gICAgICAgIHByb2Nlc3M6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IHF1ZXVlLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYiwgZGVmZXJyZWQgfSA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIHF1ZXVlLnJ1bk9uZShjYikudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBydW5PbmU6IChjYikgPT4ge1xuICAgICAgICAgICAgKytxdWV1ZS5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4gY2IoKSkoKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAtLXF1ZXVlLmNvdW50O1xuICAgICAgICAgICAgICAgIHF1ZXVlLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlOiBhc3luYyAoY2IpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5jb3VudCA+PSBxdWV1ZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICAgICAgICAgIHF1ZXVlLnF1ZXVlLnB1c2goeyBjYiwgZGVmZXJyZWQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVldWUucnVuT25lKGNiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gZGVsYXkobWlsbGlzZWNvbmRzLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUodCksIG1pbGxpc2Vjb25kcyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XG5mdW5jdGlvbiBkZWxheUNoYWluKG1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiB0YXAoKCkgPT4gZGVsYXkobWlsbGlzZWNvbmRzKSk7XG59XG5leHBvcnRzLmRlbGF5Q2hhaW4gPSBkZWxheUNoYWluO1xuZnVuY3Rpb24gdGFwKGZuKSB7XG4gICAgcmV0dXJuIGFzeW5jICh0KSA9PiB7XG4gICAgICAgIGF3YWl0IGZuKHQpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xufVxuZXhwb3J0cy50YXAgPSB0YXA7XG5mdW5jdGlvbiBwcm9wcyhvYmopIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBjb25zdCBhd2FpdGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhvYmopKVxuICAgICAgICBhd2FpdGVycy5wdXNoKFByb21pc2UucmVzb2x2ZShvYmpbcHJvcF0pXG4gICAgICAgICAgICAudGhlbih2YWwgPT4geyByZXRbcHJvcF0gPSB2YWw7IH0pKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXdhaXRlcnMpLnRoZW4oKCkgPT4gcmV0KTtcbn1cbmV4cG9ydHMucHJvcHMgPSBwcm9wcztcbmNvbnN0IGRlZmF1bHRGaWx0ZXJNYXBPcHRpb25zID0geyBjb25jdXJyZW5jeTogSW5maW5pdHkgfTtcbmZ1bmN0aW9uIGZpbHRlcihhcnIsIG9wdHMsIGZpbHRlckZuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZmlsdGVyRm4gPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyA9IGRlZmF1bHRGaWx0ZXJNYXBPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZSA9IGZpbHRlcihvcHRzLCBmaWx0ZXJGbik7XG4gICAgICAgIHJldHVybiBpbnRlcm1lZGlhdGUoYXJyKTtcbiAgICB9XG4gICAgZmlsdGVyRm4gPSB0eXBlb2YgYXJyID09PSBcImZ1bmN0aW9uXCIgPyBhcnIgOiBvcHRzO1xuICAgIG9wdHMgPVxuICAgICAgICB0eXBlb2YgYXJyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gZGVmYXVsdEZpbHRlck1hcE9wdGlvbnNcbiAgICAgICAgICAgIDogYXJyO1xuICAgIGNvbnN0IHdyYXBwZWRGaWx0ZXJGbiA9ICh2YWwsIGluZGV4LCBhcnIpID0+IFByb21pc2UucmVzb2x2ZShmaWx0ZXJGbih2YWwsIGluZGV4LCBhcnIpKVxuICAgICAgICAudGhlbihvayA9PiAoeyBvaywgdmFsIH0pKTtcbiAgICByZXR1cm4gKHQpID0+IHtcbiAgICAgICAgcmV0dXJuIG1hcChvcHRzLCB3cmFwcGVkRmlsdGVyRm4pKHQpXG4gICAgICAgICAgICAudGhlbih2YWx1ZXMgPT4gdmFsdWVzXG4gICAgICAgICAgICAuZmlsdGVyKCh7IG9rIH0pID0+IG9rKVxuICAgICAgICAgICAgLm1hcCgoeyB2YWwgfSkgPT4gdmFsKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZnVuY3Rpb24gbWFwKGFyciwgb3B0cywgbWFwRm4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYXBGbiA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0gZGVmYXVsdEZpbHRlck1hcE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcChvcHRzLCBtYXBGbikoYXJyKTtcbiAgICB9XG4gICAgbWFwRm4gPSB0eXBlb2YgYXJyID09PSBcImZ1bmN0aW9uXCIgPyBhcnIgOiBvcHRzO1xuICAgIG9wdHMgPVxuICAgICAgICB0eXBlb2YgYXJyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gZGVmYXVsdEZpbHRlck1hcE9wdGlvbnNcbiAgICAgICAgICAgIDogYXJyO1xuICAgIGNvbnN0IHsgY29uY3VycmVuY3kgPSBJbmZpbml0eSB9ID0gb3B0cztcbiAgICBjb25zdCBwcm9taXNlTWFwRm4gPSAodCwgaW5kZXgsIGFycikgPT4gUHJvbWlzZS5yZXNvbHZlKG1hcEZuKHQsIGluZGV4LCBhcnIpKTtcbiAgICBjb25zdCBjb25jdXJyZW50bHkgPSBjb25jdXJyZW50KGNvbmN1cnJlbmN5KTtcbiAgICByZXR1cm4gKHQpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0KVxuICAgICAgICAgICAgLnRoZW4oKHZhbHVlcykgPT4gdG9SZWFkb25seUFycmF5KHZhbHVlcykubWFwKCh2YWwsIGluZGV4LCBhcnIpID0+ICgoKSA9PiBQcm9taXNlLnJlc29sdmUodmFsKSkoKVxuICAgICAgICAgICAgLnRoZW4oKHZhbCkgPT4gY29uY3VycmVudGx5KHByb21pc2VNYXBGbiwgdmFsLCBpbmRleCwgYXJyKSkpKVxuICAgICAgICAgICAgLnRoZW4odmFsdWVzID0+IFByb21pc2UuYWxsKHZhbHVlcykpO1xuICAgIH07XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbmZ1bmN0aW9uIHJlZHVjZShpbnB1dCwgcmVkdWNlciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IHJlZHVjZXI7XG4gICAgICAgIGNvbnN0IF9yZWR1Y2VyID0gaW5wdXQ7XG4gICAgICAgIHJldHVybiBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VJbXBsKGlucHV0LCBfcmVkdWNlciwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZHVjZUltcGwoaW5wdXQsIHJlZHVjZXIsIGluaXRpYWxWYWx1ZSk7XG59XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmFzeW5jIGZ1bmN0aW9uIHJlZHVjZUltcGwoaW5wdXQsIHJlZHVjZXIsIGluaXRpYWxWYWx1ZSkge1xuICAgIGNvbnN0IF9pbnB1dCA9IEFycmF5LmZyb20oYXdhaXQgaW5wdXQpO1xuICAgIGNvbnN0IF9pbml0aWFsVmFsdWUgPSBhd2FpdCBpbml0aWFsVmFsdWU7XG4gICAgaWYgKF9pbnB1dC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBfaW5pdGlhbFZhbHVlO1xuICAgIGNvbnN0IHVzaW5nSW5pdGlhbFZhbHVlID0gdHlwZW9mIF9pbml0aWFsVmFsdWUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgY29uc3QgbGVuZ3RoID0gX2lucHV0Lmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSB1c2luZ0luaXRpYWxWYWx1ZSA/IDAgOiAxO1xuICAgIGxldCBhY2N1bXVsYXRvciA9IHVzaW5nSW5pdGlhbFZhbHVlXG4gICAgICAgID8gX2luaXRpYWxWYWx1ZVxuICAgICAgICAvLyBUaGlzIGNhc3Qgc2hvdWxkIGJlIHNhZmUgaWYgdGhlIGludGVyZmFjZSBpcyByZXNwZWN0ZWRcbiAgICAgICAgOiBhd2FpdCBfaW5wdXQuc2hpZnQoKTtcbiAgICB3aGlsZSAoX2lucHV0Lmxlbmd0aCA+IDApXG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXdhaXQgcmVkdWNlcihhY2N1bXVsYXRvciwgYXdhaXQgX2lucHV0LnNoaWZ0KCksIGluZGV4KyssIGxlbmd0aCk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuZnVuY3Rpb24gZWFjaChhcnIsIGVhY2hGbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBlYWNoSW1wbChlYWNoRm4pKGFycik7XG4gICAgcmV0dXJuIGVhY2hJbXBsKGFycik7XG59XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZnVuY3Rpb24gZWFjaEltcGwoZWFjaEZuKSB7XG4gICAgcmV0dXJuIGFzeW5jIChhcnIpID0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gaXRlcmF0b3IodCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGF3YWl0IGVhY2hGbih0LCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXAoYXJyLCB7IGNvbmN1cnJlbmN5OiAxIH0sIGl0ZXJhdG9yKTtcbiAgICB9O1xufVxuZXhwb3J0cy5lYWNoSW1wbCA9IGVhY2hJbXBsO1xuZnVuY3Rpb24gc29tZShsaXN0LCBmbikge1xuICAgIGlmICh0eXBlb2YgbGlzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gbGlzdDtcbiAgICAgICAgcmV0dXJuIChsaXN0KSA9PiBzb21lSW1wbChsaXN0LCBmbik7XG4gICAgfVxuICAgIHJldHVybiBzb21lSW1wbChsaXN0LCBmbik7XG59XG5leHBvcnRzLnNvbWUgPSBzb21lO1xuYXN5bmMgZnVuY3Rpb24gc29tZUltcGwobGlzdCwgZm4pIHtcbiAgICBjb25zdCBfbGlzdCA9IHRvUmVhZG9ubHlBcnJheShhd2FpdCBsaXN0KTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBfbGlzdCkge1xuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBmbihhd2FpdCB2YWwpO1xuICAgICAgICBpZiAocmV0KVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGlmIChmbikge1xuICAgICAgICBjb25zdCBfb25jZSA9IG9uY2VEeW5hbWljKCk7XG4gICAgICAgIHJldHVybiAoKHQpID0+IF9vbmNlKGZuLCB0KSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG9uY2VEeW5hbWljKCk7XG59XG5leHBvcnRzLm9uY2UgPSBvbmNlO1xuZnVuY3Rpb24gb25jZUR5bmFtaWMoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IGVuc3VyZVN0YXRlID0gKGZuKSA9PiB7XG4gICAgICAgIGlmICghc3RhdGUuaGFzKGZuKSlcbiAgICAgICAgICAgIHN0YXRlLnNldChmbiwgeyBoYXNSdW46IGZhbHNlIH0pO1xuICAgIH07XG4gICAgcmV0dXJuICgoZm4sIHQpID0+IHtcbiAgICAgICAgZW5zdXJlU3RhdGUoZm4pO1xuICAgICAgICBjb25zdCBzdGF0ZU9iamVjdCA9IHN0YXRlLmdldChmbik7XG4gICAgICAgIGlmIChzdGF0ZU9iamVjdC5oYXNSdW4pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZU9iamVjdC5kZWZlcnJlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVPYmplY3QuZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZU9iamVjdC5yZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZU9iamVjdC5oYXNSdW4gPSB0cnVlO1xuICAgICAgICBjb25zdCByZXQgPSBmbih0KTtcbiAgICAgICAgY29uc3QgcHJldCA9IHJldDtcbiAgICAgICAgaWYgKHByZXQgIT09IHVuZGVmaW5lZCAmJiBwcmV0ICYmIHR5cGVvZiBwcmV0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc3RhdGVPYmplY3QuZGVmZXJyZWQgPSBkZWZlcih2b2lkIDApO1xuICAgICAgICAgICAgcmV0dXJuIHByZXRcbiAgICAgICAgICAgICAgICAudGhlbihzdGF0ZU9iamVjdC5kZWZlcnJlZC5yZXNvbHZlLCByZXRocm93KHN0YXRlT2JqZWN0LmRlZmVycmVkLnJlamVjdCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gc3RhdGVPYmplY3QuZGVmZXJyZWQucHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVPYmplY3QucmV0dXJuVmFsdWUgPSByZXQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXRyeSh0aW1lcywgZm4sIHJldHJ5YWJsZSA9ICgpID0+IHRydWUpIHtcbiAgICBjb25zdCByZXRyeUFzeW5jID0gKHByb21pc2UpID0+IHByb21pc2VcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKC0tdGltZXMgPCAwIHx8ICFyZXRyeWFibGUoZXJyKSlcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgcmV0dXJuIHJldHJ5QXN5bmMoZm4oKSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmV0cnlTeW5jID0gKF9lcnIpID0+IHtcbiAgICAgICAgd2hpbGUgKC0tdGltZXMgPj0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5YWJsZShlcnIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgX2VyciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBfZXJyO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gZm4oKTtcbiAgICAgICAgaWYgKHJldCAmJlxuICAgICAgICAgICAgdHlwZW9mIHJldCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHJldC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeUFzeW5jKHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIXJldHJ5YWJsZShlcnIpKVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICByZXR1cm4gcmV0cnlTeW5jKGVycik7XG4gICAgfVxufVxuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGRlZmVycmVkID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICgoKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkpFU1RfV09SS0VSX0lEKSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSmVzdCBoYXMgZGVjaWRlZCBmb3IgbWFueSB2ZXJzaW9ucyB0byBicmVhayBhc3luYyBjYXRjaGluZyxcbiAgICAgICAgICAgIC8vIHNvIHRoaXMgaXMgbmVlZGVkIGZvciB1bml0IHRlc3RzIG5vdCB0byBicmVhayB1bm5lY2Vzc2FyaWx5LlxuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZXJyKSB7IH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5leHBvcnRzLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiByZWZsZWN0KHByb21pc2UpIHtcbiAgICBjb25zdCBpbnNwZWN0aW9uID0gaW5zcGVjdChwcm9taXNlKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1JlamVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlzUmVqZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpc1Jlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3BlY3Rpb24ucHJvbWlzZVxuICAgICAgICAudGhlbihoYW5kbGVSZXNvbHV0aW9uLCBoYW5kbGVSZWplY3Rpb24pO1xufVxuZXhwb3J0cy5yZWZsZWN0ID0gcmVmbGVjdDtcbmZ1bmN0aW9uIGluc3BlY3QocHJvbWlzZSkge1xuICAgIGNvbnN0IGluc3BlY3RhYmxlID0ge1xuICAgICAgICBpc1BlbmRpbmc6IHRydWUsXG4gICAgICAgIGlzUmVqZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1Jlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgcHJvbWlzZTogdm9pZCAwLFxuICAgIH07XG4gICAgaW5zcGVjdGFibGUucHJvbWlzZSA9IHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgIGluc3BlY3RhYmxlLmlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBpbnNwZWN0YWJsZS5pc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpbnNwZWN0YWJsZS5pc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zcGVjdGFibGUuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbnNwZWN0YWJsZTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5mdW5jdGlvbiBkZWZlckluc3BlY3RhYmxlKCkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICAgIGlzUGVuZGluZzogdHJ1ZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGlzUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICBwcm9taXNlOiBkZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICByZXNvbHZlKHQpIHtcbiAgICAgICAgICAgIGlmICghcmV0LmlzUGVuZGluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHQpO1xuICAgICAgICAgICAgcmV0LmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldC5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVqZWN0KGVycikge1xuICAgICAgICAgICAgaWYgKCFyZXQuaXNQZW5kaW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgcmV0LmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0LmlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLmRlZmVySW5zcGVjdGFibGUgPSBkZWZlckluc3BlY3RhYmxlO1xuLy8gVGhpcyBsb2dpYyBpcyB0YWtlbiBmcm9tIEJsdWViaXJkXG5mdW5jdGlvbiBjYXRjaEZpbHRlcihmaWx0ZXJzLCBlcnIpIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoZmlsdGVycykgPyBmaWx0ZXJzIDogW2ZpbHRlcnNdKVxuICAgICAgICAuc29tZSgoZmlsdGVyKSA9PiB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgIGZpbHRlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGZpbHRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gZmlsdGVyO1xuICAgICAgICAgICAgLy8gSXQgaXMgXCJva1wiIGZvciB0aGlzIHRvIHRocm93LiBJdCdsbCBiZSB0aHJvd24gYmFjayB0byB0aGUgY2F0Y2hcbiAgICAgICAgICAgIC8vIGhhbmRsZXIsIGFuZCB0aGUgcHJvbWlzZSBjaGFpbiB3aWxsIGNvbnRhaW4gdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJGbihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IGZpbHRlcjtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpXG4gICAgICAgICAgICAgICAgaWYgKG9ialtrZXldICE9PSBlcnJba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc3BlY2lmaWMoZmlsdGVycywgaGFuZGxlcikge1xuICAgIHJldHVybiAoZXJyKSA9PiB7XG4gICAgICAgIGlmICghY2F0Y2hGaWx0ZXIoZmlsdGVycywgZXJyKSlcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoZXJyKTtcbiAgICB9O1xufVxuZXhwb3J0cy5zcGVjaWZpYyA9IHNwZWNpZmljO1xuZnVuY3Rpb24gcmV0aHJvdyhmbikge1xuICAgIHJldHVybiBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgIGF3YWl0IGZuKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9O1xufVxuZXhwb3J0cy5yZXRocm93ID0gcmV0aHJvdztcbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbih3cmFwKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBjYikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHdyYXAubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZhbEVycm9yKFwiSW52YWxpZCBpbnZvY2F0aW9uLCBmdW5jdGlvbiByZXF1aXJlcyAyIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgICAgIGNiID0gdDtcbiAgICAgICAgICAgIHQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55Q2xlYW51cCA9IHdyYXAodCk7XG4gICAgICAgIGNvbnN0IGNhbGxDbGVhbnVwID0gKGNsZWFudXApID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbnVwKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjbGVhbnVwICE9IG51bGwpXG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgJ2JlZm9yZScgdG8ganVzdCByZXR1cm4gbnVsbC91bmRlZmluZWQsIGJ1dCBub24tZW1wdHlcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSB3b3VsZCd2ZSBiZWVuIHNpbGVudGx5IGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2YWxFcnJvcihcIkludmFsaWQgcmV0dXJuIHZhbHVlIGluICdiZWZvcmUnIGhhbmRsZXJcIik7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhbnlDbGVhbnVwICYmXG4gICAgICAgICAgICB0eXBlb2YgYW55Q2xlYW51cC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxldCBkb0NsZWFudXA7XG4gICAgICAgICAgICByZXR1cm4gYW55Q2xlYW51cFxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIChjbGVhbnVwKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9DbGVhbnVwID0gKCkgPT4gY2FsbENsZWFudXAoY2xlYW51cCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9DbGVhbnVwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9DbGVhbnVwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBhbnlDbGVhbnVwO1xuICAgICAgICAgICAgbGV0IGNiUmV0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYlJldCA9IGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW51cFJldCA9IGNhbGxDbGVhbnVwKGNsZWFudXApO1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwUmV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjbGVhbnVwUmV0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xlYW51cFJldFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYlJldCAmJiB0eXBlb2YgY2JSZXQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiUmV0XG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IGNhbGxDbGVhbnVwKGNsZWFudXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFudXBSZXQgPSBjYWxsQ2xlYW51cChjbGVhbnVwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cFJldCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2xlYW51cFJldC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFudXBSZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGNiUmV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYlJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy53cmFwRnVuY3Rpb24gPSB3cmFwRnVuY3Rpb247XG5mdW5jdGlvbiBmdW5uZWwob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBvbkVtcHR5LCBjb25jdXJyZW5jeSA9IDEgfSA9IChvcHRzIHx8IHt9KTtcbiAgICBsZXQgRnVubmVsU3RhdGU7XG4gICAgKGZ1bmN0aW9uIChGdW5uZWxTdGF0ZSkge1xuICAgICAgICBGdW5uZWxTdGF0ZVtGdW5uZWxTdGF0ZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgICAgICBGdW5uZWxTdGF0ZVtGdW5uZWxTdGF0ZVtcIlNIT1VMRF9SRVRSWVwiXSA9IDFdID0gXCJTSE9VTERfUkVUUllcIjtcbiAgICAgICAgRnVubmVsU3RhdGVbRnVubmVsU3RhdGVbXCJXQUlUSU5HXCJdID0gMl0gPSBcIldBSVRJTkdcIjtcbiAgICAgICAgRnVubmVsU3RhdGVbRnVubmVsU3RhdGVbXCJDT01QTEVURURcIl0gPSAzXSA9IFwiQ09NUExFVEVEXCI7XG4gICAgfSkoRnVubmVsU3RhdGUgfHwgKEZ1bm5lbFN0YXRlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBBbGwgb25nb2luZyB0YXNrcyAoZnVuY3Rpb25zKSByZWdhcmRsZXNzIG9mIHN0YXRlIHRoZXkgYXJlIGluLlxuICAgICAqIElmIHRoZXkgcmV0dXJuL3Rocm93IG9yIHNob3J0Y3V0LCB0aGV5IGdldCBjbGVhcmVkIGZyb20gdGhpcyBtYXAuXG4gICAgICogVGhlIG9yZGVyIGlzIHByZXNlcnZlZCBmb3IgZmlmbyBmYWlybmVzcy5cbiAgICAgKi9cbiAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb3VudFdhaXRpbmcgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBbLi4udGFza3MudmFsdWVzKCldXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHN0YXRlIH0pID0+IHN0YXRlID09PSBGdW5uZWxTdGF0ZS5XQUlUSU5HKVxuICAgICAgICAgICAgLmxlbmd0aDtcbiAgICB9O1xuICAgIGNvbnN0IGNvdW50V29ya2luZyA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIFsuLi50YXNrcy52YWx1ZXMoKV1cbiAgICAgICAgICAgIC5maWx0ZXIoKHsgc3RhdGUgfSkgPT4gc3RhdGUgPT09IEZ1bm5lbFN0YXRlLlNIT1VMRF9SRVRSWSlcbiAgICAgICAgICAgIC5sZW5ndGg7XG4gICAgfTtcbiAgICBjb25zdCBmcmVlU2xvdHMgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBjb25jdXJyZW5jeSAtIGNvdW50V29ya2luZygpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXJXYWl0aW5nID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBhbW91bnRUb1Jlc3VtZSA9IGZyZWVTbG90cygpO1xuICAgICAgICBbLi4udGFza3MudmFsdWVzKCldXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHN0YXRlIH0pID0+IHN0YXRlID09PSBGdW5uZWxTdGF0ZS5XQUlUSU5HKVxuICAgICAgICAgICAgLnNsaWNlKDAsIGFtb3VudFRvUmVzdW1lKVxuICAgICAgICAgICAgLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgICAgICB0YXNrLnJlc3VtZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoZm4pID0+IHtcbiAgICAgICAgY29uc3Qgc2VudHJ5ID0ge307XG4gICAgICAgIGNvbnN0IHN0b3JlID0ge1xuICAgICAgICAgICAgc3RhdGU6IEZ1bm5lbFN0YXRlLkRFRkFVTFQsXG4gICAgICAgICAgICBjb3VudGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VtZTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0YXNrcy5zZXQoc2VudHJ5LCBzdG9yZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3JlLnN0YXRlID09PSBGdW5uZWxTdGF0ZS5DT01QTEVURUQpXG4gICAgICAgICAgICAgICAgLy8gc2hvcnRjdXQgYmVmb3JlIHNob3VsZC9yZXRyeSBzaG9ydGN1dHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGZyZWUgPSBmcmVlU2xvdHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gZnJlZSA+IDA7XG4gICAgICAgICAgICBpZiAoc3RvcmUuc3RhdGUgIT09IEZ1bm5lbFN0YXRlLkRFRkFVTFQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1c2Ugb2YgJ3Nob3VsZFJldHJ5J1wiKTtcbiAgICAgICAgICAgIHN0b3JlLnN0YXRlID0gRnVubmVsU3RhdGUuU0hPVUxEX1JFVFJZO1xuICAgICAgICAgICAgc3RvcmUuY291bnRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gIXNob3VsZENvbnRpbnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXRyeSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9yZS5zdGF0ZSAhPT0gRnVubmVsU3RhdGUuU0hPVUxEX1JFVFJZKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXNlIG9mICdyZXRyeScsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJtdXN0IG9ubHkgYmUgY2FsbGVkIGFmdGVyICdzaG91bGRSZXRyeSdcIik7XG4gICAgICAgICAgICBzdG9yZS5zdGF0ZSA9IEZ1bm5lbFN0YXRlLldBSVRJTkc7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bWUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUuc3RhdGUgPSBGdW5uZWxTdGF0ZS5ERUZBVUxUO1xuICAgICAgICAgICAgICAgIHN0b3JlLnJlc3VtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJ1bm5lcigpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdG9yZS5yZXN1bWUgPSByZXN1bWU7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2hvcnRjdXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcmUuc3RhdGUgPT09IEZ1bm5lbFN0YXRlLkNPTVBMRVRFRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdG9yZS5zdGF0ZSA9IEZ1bm5lbFN0YXRlLkNPTVBMRVRFRDtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZShzZW50cnkpO1xuICAgICAgICAgICAgaWYgKGNvdW50V2FpdGluZygpID09PSAwKVxuICAgICAgICAgICAgICAgIG9uRW1wdHkgPT09IG51bGwgfHwgb25FbXB0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FbXB0eSgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyaWdnZXJXYWl0aW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4gZm4oc2hvdWxkUmV0cnksIHJldHJ5LCBzaG9ydGN1dCkpKClcbiAgICAgICAgICAgICAgICAuZmluYWxseShzaG9ydGN1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBydW5uZXIoKTtcbiAgICB9O1xufVxuZXhwb3J0cy5mdW5uZWwgPSBmdW5uZWw7XG5jbGFzcyBPcmRlcmVkQXN5bmNocm9ueSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGVmZXJyYWxzID0gW107XG4gICAgfVxuICAgIHdhaXQod2FpdEZvckluZGV4LCByZXNvbHZlSW5kZXgsIHJlamVjdEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5zdXJlRGVmZXJyYWwoW1xuICAgICAgICAgICAgLi4uKFtdLmNvbmNhdCh3YWl0Rm9ySW5kZXgpKSxcbiAgICAgICAgICAgIC4uLihyZXNvbHZlSW5kZXggPT0gbnVsbCA/IFtdIDpcbiAgICAgICAgICAgICAgICBbXS5jb25jYXQocmVzb2x2ZUluZGV4KSksXG4gICAgICAgICAgICAuLi4ocmVqZWN0SW5kZXggPT0gbnVsbCA/IFtdIDpcbiAgICAgICAgICAgICAgICBbXS5jb25jYXQocmVqZWN0SW5kZXgpKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRlKFByb21pc2UuYWxsKFtdLmNvbmNhdCh3YWl0Rm9ySW5kZXgpXG4gICAgICAgICAgICAubWFwKGluZGV4ID0+IHRoaXMuZGVmZXJyYWxzW2luZGV4XS5wcm9taXNlKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHJlc29sdmVJbmRleCA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICA6IHRoaXMucmVzb2x2ZShyZXNvbHZlSW5kZXgpLFxuICAgICAgICAgICAgcmVqZWN0SW5kZXggPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJlamVjdChyZWplY3RJbmRleCksXG4gICAgICAgIF0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7IH0pKSk7XG4gICAgfVxuICAgIHJlc29sdmUoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVEZWZlcnJhbChpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRlKGRlbGF5KDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgW10uY29uY2F0KGluZGV4KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmFsc1tpbmRleF0ucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVqZWN0KGluZGV4LCBlcnJvciA9IG5ldyBFcnJvcihcIk9yZGVyZWRBc3luY2hyb255IHJlamVjdGlvblwiKSkge1xuICAgICAgICB0aGlzLmVuc3VyZURlZmVycmFsKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGUoZGVsYXkoMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBbXS5jb25jYXQoaW5kZXgpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyYWxzW2luZGV4XS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZW5zdXJlRGVmZXJyYWwoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IFtdXG4gICAgICAgICAgICAuY29uY2F0KGluZGV4KVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcbiAgICAgICAgY29uc3QgaGlnaGVzdCA9IGluZGljZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRlZmVycmFscy5sZW5ndGg7IGkgPD0gaGlnaGVzdDsgKytpKVxuICAgICAgICAgICAgdGhpcy5kZWZlcnJhbHMucHVzaChkZWZlcih2b2lkIDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlY29yYXRlKHByb21pc2UpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgY29uc3QgVGhpcyA9IHtcbiAgICAgICAgICAgIGRlY29yYXRlOiB0aGlzLmRlY29yYXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWZlcnJhbHM6IHRoaXMuZGVmZXJyYWxzLFxuICAgICAgICAgICAgZW5zdXJlRGVmZXJyYWw6IHRoaXMuZW5zdXJlRGVmZXJyYWwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlamVjdDogdGhpcy5yZWplY3QuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlc29sdmU6IHRoaXMucmVzb2x2ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgd2FpdDogdGhpcy53YWl0LmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIFRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3JkZXJlZEFzeW5jaHJvbnkgPSBPcmRlcmVkQXN5bmNocm9ueTtcbmZ1bmN0aW9uIGRlZmVyU2V0KCkge1xuICAgIHJldHVybiBuZXcgT3JkZXJlZEFzeW5jaHJvbnkoKTtcbn1cbmV4cG9ydHMuZGVmZXJTZXQgPSBkZWZlclNldDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/already/dist/index.js\n");

/***/ })

};
;